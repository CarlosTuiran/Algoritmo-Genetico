# -*- coding: utf-8 -*-
"""Algoritmo Genetico

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fP9IfbaVlR6q_HfGiyw7tPqepfyM8aqF

**Pasos de Un Algoritmo Genetico**

![Pasos de un Algortimo Genetico](https://robologs.net/wp-content/uploads/2015/08/fases_algoritmo-1024x387.png)
"""

import random
import math
import getpass
import json
from tkinter import *    # Carga módulo tk (widgets estándar)
from tkinter import ttk, font  # Carga ttk (para widgets nuevos 8.5+)

modelo = [0,0,0,0,0,0,0,0,0,0] 
minPob=1 #Rango Minimo de Poblacion
maxPob=100 #Rango Maximo de Poblacion 
#datos_modelo=StringVar()
largo = 10 #La longitud del material genetico de cada individuo
num = 12 #La cantidad de individuos que habra en la poblacion
pressure = int(round(num*0.3)) #Cuantos individuos se seleccionan para reproduccion. Necesariamente mayor que 2
mutation_chance = 0.2 #La probabilidad de que un individuo mute
generations=200  #Numero de Generaciones


#Convertir el vector binario a decimal			
def convertirVectoraBinario(vec):
	 cadena=json.dumps(vec)
	 new1=cadena.replace("[","")
	 new2=new1.replace("]","")
	 new3=new2.replace(",","")
	 new4=new3.replace(" ","")
	 numfinal=int(new4, 2)
	 return numfinal
"""Definir el Modelo o individuo a maximizar
"""
def definirModelo(vec):
	global modelo
	num= convertirVectoraBinario(vec)
	numModel= convertirVectoraBinario(modelo)
	if num>numModel:
		modelo=vec
		

"""Crea un individuo  
 Recibe como parámetros dos números enteros (un mínimo y un máximo) y se llena una lista de longitud dada por la variable ‘largo‘ con números aleatorios entre el mínimo y el máximo. Esta lista creada será el nuevo individuo.
"""
def individual(min, max):
	individuo=[random.randint(min, max) for i in range(largo)]
	print(str(individuo))
	definirModelo(individuo)
	return individuo

"""Crear una población 
Llama la función para crear individuales un número de veces igual a ‘num‘, que definía el tamaño de la población. Todos estos nuevos individuales los guarda dentro de una lista, que devuelve fuera de la función.
"""

def crearPoblacion():
    """
        Crea una poblacion nueva de individuos
    """
    return [individual(0,1) for i in range(num)]

"""Función de Fitness.
 Dado un individuo, la función comprueba cuántos números tiene en común con el modelo y le asigna el fitness correspondiente. Después devuelve este número fuera de la función.
"""

def calcularFitness(individual):
    """
        Calcula el fitness de un individuo concreto y sacar los que se salen del rango.
    """
    fitness = 0
    numInd= convertirVectoraBinario(individual)
    if numInd<=maxPob and numInd>=minPob :
      for i in range(len(individual)):
       if individual[i] == modelo[i]:
           fitness += 1  
    return fitness

"""La Funcion selection_and_reproduction() para evaluar cada uno de los individuos (evaluación), seleccionar los mejores (selección) y mezclar su material genético (crossover) a fin de crear una nueva población encima de la anterior."""

def selection_and_reproduction(population):
    """
        Puntua todos los elementos de la poblacion (population) y se queda con los mejores
        guardandolos dentro de 'selected'.
        Despues mezcla el material genetico de los elegidos para crear nuevos individuos y
        llenar la poblacion (guardando tambien una copia de los individuos seleccionados sin
        modificar).
  
        Por ultimo muta a los individuos.
  
    """
    puntuados = [ (calcularFitness(i), i) for i in population] #Calcula el fitness de cada individuo, y lo guarda en pares ordenados de la forma (5 , [1,2,1,1,4,1,8,9,4,1])
    puntuados = [i[1] for i in sorted(puntuados)] #Ordena los pares ordenados de menor a mayor y se queda solo con el array de valores
    population = puntuados
  
  
  
    selected =  puntuados[(len(puntuados)-pressure):] #Esta linea selecciona los 'n' individuos del final, donde n viene dado por 'pressure'
  
  
  
    #Se mezcla el material genetico para crear nuevos individuos
    for i in range(len(population)-pressure):
        punto = random.randint(1,largo-1) #Se elige un punto para hacer el intercambio
        padre = random.sample(selected, 2) #Se eligen dos padres
          
        population[i][:punto] = padre[0][:punto] #Se mezcla el material genetico de los padres en cada nuevo individuo
        population[i][punto:] = padre[1][punto:]
  
    return population #El array 'population' tiene ahora una nueva poblacion de individuos, que se devuelven

"""Función de mutación
 que añada pequeñas variaciones al azar en el array de los individuos de la nueva generación.
"""

def mutation(population):
    """
        Se mutan los individuos al azar. Sin la mutacion de nuevos genes nunca podria
        alcanzarse la solucion.
    """
    for i in range(len(population)-pressure):
        if random.random() <= mutation_chance: #Cada individuo de la poblacion (menos los padres) tienen una probabilidad de mutar
            punto = random.randint(0,largo-1) #Se elgie un punto al azar
            nuevo_valor = random.randint(0,1) #y un nuevo valor para este punto
  
            #Es importante mirar que el nuevo valor no sea igual al viejo
            while nuevo_valor == population[i][punto]:
                nuevo_valor = random.randint(0,1)
  
            #Se aplica la mutacion
            population[i][punto] = nuevo_valor
  
    return population
def reDefinirNuevoModelo(population):
		for i in population:
			definirModelo(i)


"""GUI"""

class Aplicacion():
    def __init__(self):
      self.raiz = Tk() # Define la ventana principal de la aplicación
      self.raiz.geometry('1400x800')
      self.raiz.resizable(0,0) # Establece que no se pueda cambiar el tamaño de la ventana
      self.raiz.configure(bg = 'beige') # Asigna un color de fondo a la ventana.
      self.raiz.title('Algoritmo Genetico') # Asigna un título a la ventana
      fuente= font.Font(weight='bold')
      #ETIQUETAS
      self.etiqMinPob = ttk.Label(self.raiz, text="Rango Min de Poblacion:", font=fuente)
      self.etiqMaxPob = ttk.Label(self.raiz, text="Rango Max de Poblacion:", font=fuente)
      self.etiqLong = ttk.Label(self.raiz, text="Longitud del Material", font=fuente)
      self.etiqCant = ttk.Label(self.raiz, text="Muestra de individuos:", font=fuente)
      self.etiqMuta = ttk.Label(self.raiz, text="(%) de Mutacion:", font=fuente)
      self.etiqGen = ttk.Label(self.raiz, text="Generaciones:", font=fuente)
      #Variables de Entorno
      self.minPob=IntVar(value=1)
      self.maxPob=IntVar(value=100)
      self.largo=IntVar(value=10)
      self.num=IntVar(value=10)
      self.mutation_chance=DoubleVar(value=0.3)
      self.generations=IntVar(value=100)

      #CAJAS DE TEXTO
      self.ctextMinPob = ttk.Entry(self.raiz, textvariable=minPob, width=30)
      self.ctextMaxPob = ttk.Entry(self.raiz, textvariable=maxPob, width=30)
      self.ctextLong = ttk.Entry(self.raiz, textvariable=largo, width=30)
      self.ctextCant = ttk.Entry(self.raiz, textvariable=num, width=30)
      self.ctextMuta = ttk.Entry(self.raiz, textvariable=mutation_chance, width=30)
      self.ctextGen = ttk.Entry(self.raiz, textvariable=generations, width=30)
      self.separ1 = ttk.Separator(self.raiz, orient=HORIZONTAL)
      self.tinfo = Text(self.raiz, width=50, height=10) # Define el widget Text 'self.tinfo ' en el que se pueden introducir varias líneas de texto:
      self.separ2 = ttk.Separator(self.raiz, orient=HORIZONTAL)
      #BOTONES
      self.binfo = ttk.Button(self.raiz, text='Info', padding=(5,5), command=self.verinfo) #Define el widget Button 'self.binfo' que llamará al metodo 'self.verinfo' cuando sea presionado
      self.bsalir = ttk.Button(self.raiz, text='Salir', #Define el botón 'self.bsalir'. En este caso  cuando sea presionado, el método destruirá o terminara la aplicación-ventana 'self.raíz' con 'self.raiz.destroy'
                               padding=(5,5), command=self.raiz.destroy) 
      #Actualizar Presion

      #AJUSTANDO WIDGETS
      self.etiqMinPob.place(x=40, y=80)
      self.ctextMinPob.place(x=40, y=100)
      self.etiqMaxPob.place(x=250, y=80)
      self.ctextMaxPob.place(x=250, y=100)
      self.etiqLong.place(x=460, y=80)
      self.ctextLong.place(x=460, y=100)
      self.etiqCant.place(x=680, y=80)
      self.ctextCant.place(x=680, y=100)
      self.etiqMuta.place(x=900, y=80)
      self.ctextMuta.place(x=900, y=100)
      self.etiqGen.place(x=1100, y=80)
      self.ctextGen.place(x=1100, y=100)
      self.separ1.place(x=5, y=140, bordermode=OUTSIDE, height=10, width=1320)
      self.tinfo.place(x=40, y=150) # Sitúa la caja de texto 'self.tinfo' en la parte INFERIOR 
      self.separ2.place(x=5, y=400, bordermode=OUTSIDE, height=10, width=1320)      
      self.binfo.place(x=40, y=700) #Coloca el botón 'self.binfo' debajo y a la izquierda del widget anterior      
      self.bsalir.place(x=1300, y=700) #Coloca el botón 'self.bsalir' a la derecha del  objeto anterior. 

      self.binfo.focus_set() #El foco de la aplicación se sitúa en el botón  'binfo' resaltando su borde.
      self.raiz.mainloop()

    def verinfo(self):
    	
    	error_dato=False
    	global minPob
    	global maxPob
    	global largo
    	global num
    	global mutation_chance
    	global generations
    	global pressure
    	try:
    		minPob=int(self.minPob.get())
    		maxPob=int(self.maxPob.get())
    		largo=int(self.largo.get())
    		num=int(self.num.get())
    		mutation_chance=float(self.mutation_chance.get())
    		generations=int(self.generations.get())
    		pressure = int(round(num*0.3))
    	except:
    		error_dato=True
    	self.tinfo.delete("1.0", END) # Borra el contenido que tenga en un momento dado la caja de texto
    	if not error_dato:
	      population = crearPoblacion()#Inicializar una poblacion
	      texto_info="\n Poblacion Inicial:\n"+ str(population)+"\n"
	      #SE EVOLUCIONA LA POBLACION
	      for i in range(generations):
	      	population = selection_and_reproduction(population)
	      	population = mutation(population)
	      	reDefinirNuevoModelo(population)
	      texto_info+="\nModelo:\n"+ str(modelo)+"\n"
	      texto_info+="\nPoblacion Final:\n"+ str(population)+"\n"
	    else:
			texto_info="¡ERROR! REVISA DATOS"
      self.tinfo.insert("1.0", texto_info)

"""Población inicial y el bucle del programa. El algoritmo hará evolucionar a la población durante cien x generaciones, llamando las funciones que se han definido arriba

Clase Principal
"""

def main():
    mi_app = Aplicacion()
    return 0

if __name__ == '__main__':
    main()
