# -*- coding: utf-8 -*-
"""Algoritmo Genetico

Automatically generated by Colaboratory.

Original file is located at
	https://colab.research.google.com/drive/1fP9IfbaVlR6q_HfGiyw7tPqepfyM8aqF

**Pasos de Un Algoritmo Genetico**

![Pasos de un Algortimo Genetico](https://robologs.net/wp-content/uploads/2015/08/fases_algoritmo-1024x387.png)
"""

import random
import json
import matplotlib.pyplot as plt
import numpy as np
from tkinter import *    # Carga módulo tk (widgets estándar)
from tkinter import ttk, font  # Carga ttk (para widgets nuevos 8.5+)
#from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
#from matplotlib.figure import Figure
#from matplotlib import dates

modelo          = [0,0,0,0,0,0,0,0,0,0]
listamodelos    =[]
minPob          =1 #Rango Minimo de Poblacion
maxPob          =100 #Rango Maximo de Poblacion
#datos_modelo   =StringVar()
#largo           = random.randint(1, 20) #La longitud del material genetico de cada individuo
num             = 20 #La cantidad de individuos que habra en la poblacion
pressure        = int(round(num*0.3)) #Cuantos individuos se seleccionan para reproduccion. Necesariamente mayor que 2
mutation_chance = 0.2 #La probabilidad de que un individuo mute
generations     =10  #Numero de Generaciones
funcion         =" "
fitnessPopulation=[]
#Funciones Disponibles
def funLineal(num):
	return num

def funCuadratica(num):
	num=num*num
	return num

switcher	={
	"Lineal(x)":	funLineal,
	"Cuadratica(x^2)":	funCuadratica
}
#Convertir el vector binario a decimal
def convertirVectoraBinario(vec):
	 cadena=json.dumps(vec)
	 new1=cadena.replace("[","")
	 new2=new1.replace("]","")
	 new3=new2.replace(",","")
	 new4=new3.replace(" ","")
	 numfinal=int(new4, 2)
	 return numfinal
"""Definir el Modelo o individuo a maximizar
"""
def definirModelo(vec):
	global modelo
	global listamodelos
	num= convertirVectoraBinario(vec)
	numModel= convertirVectoraBinario(modelo)
	numEval=evaluarFuncion(num)
	numModelEval=evaluarFuncion(numModel)
	if numEval>numModelEval:
		modelo=vec


"""Evaluar el numero en la Funcion Correspondiente
"""
def evaluarFuncion(num):
	funcionSelect=switcher.get(funcion, "funLineal")
	numEval=funcionSelect(num)
	return numEval

"""Crea un individuo  
 Recibe como parámetros dos números enteros (un mínimo y un máximo) y se llena una lista de longitud dada por la variable ‘largo‘ con números aleatorios entre el mínimo y el máximo. Esta lista creada será el nuevo individuo.
"""
def getLargoAleatotio():
	largo=random.randint(1, 20)
	return largo

def individual(min, max):
	"""while True:
		
		num=convertirVectoraBinario(individuo)
		if num>=minPob and num<=maxPob:
			break
	print(str(num))
	definirModelo(individuo)"""
	individuo=[random.randint(min, max) for i in range(getLargoAleatotio())]
	return individuo

"""Crear una población 
Llama la función para crear individuales un número de veces igual a ‘num‘, que definía el tamaño de la población. Todos estos nuevos individuales los guarda dentro de una lista, que devuelve fuera de la función.
"""

def crearPoblacion():
	"""
		Crea una poblacion nueva de individuos en el rango definido
	"""
	return [individual(0,7) for i in range(num)]

"""Función de Fitness.
 Dado un individuo, la función comprueba cuántos números tiene en común con el modelo y le asigna el fitness correspondiente. Después devuelve este número fuera de la función.
"""

def calcularFitness(individual):
	"""
		Calcula el fitness de un individuo concreto y sacar los que se salen del rango.
	"""
	fitness = len(individual)
	"""numInd= convertirVectoraBinario(individual)
	if numInd<=maxPob and numInd>=minPob :
		for i in range(len(individual)):
		 if individual[i] == modelo[i]:
			 fitness += 1"""
	
	return fitness

"""La Funcion selection_and_reproduction() para evaluar cada uno de los individuos (evaluación), seleccionar los mejores (selección) y mezclar su material genético (crossover) a fin de crear una nueva población encima de la anterior."""
def selectionEspecific(population):
	"""Se genera un numero aleatorio  """
	global fitnessPopulation
	r=random.uniform(0, 1)
	S=0
	for i in range(fitnessPopulation):
		S=S+fitnessPopulation[i]
	C=r*S
	Ca=0
	for i in range(fitnessPopulation):
		Ca=Ca+fitnessPopulation[i]
		if Ca>C:
			newPopulation=population[i]
	return newPopulation

def selection_and_reproduction(population):
	"""
		Puntua todos los elementos de la poblacion (population) y se queda con los mejores
		guardandolos dentro de 'selected'.
		Despues mezcla el material genetico de los elegidos para crear nuevos individuos y
		llenar la poblacion (guardando tambien una copia de los individuos seleccionados sin
		modificar).

		Por ultimo muta a los individuos.

	"""
	global fitnessPopulation

	puntuados = [ (calcularFitness(i), i) for i in population] #Calcula el fitness de cada individuo, y lo guarda en pares ordenados de la forma (5 , [1,2,1,1,4,1,8,9,4,1])
	puntuados2 = [i[1] for i in sorted(puntuados)] #Ordena los pares ordenados de menor a mayor y se queda solo con el array de valores
	fitnessPopulation=[i[0] for i in sorted(puntuados)] #se queda con la calificacion ordenada
	population = selectionEspecific(puntuados)#nueva poblacion seleccionada 



	selected =  puntuados[(len(puntuados)-pressure):] #Esta linea selecciona los 'n' individuos del final, donde n viene dado por 'pressure'



	#Se mezcla el material genetico para crear nuevos individuos
	for i in range(len(population)-pressure):
		punto = random.randint(1,largo-1) #Se elige un punto para hacer el intercambio
		padre = random.sample(selected, 2) #Se eligen dos padres

		population[i][:punto] = padre[0][:punto] #Se mezcla el material genetico de los padres en cada nuevo individuo
		population[i][punto:] = padre[1][punto:]

	return population #El array 'population' tiene ahora una nueva poblacion de individuos, que se devuelven

"""Función de mutación
 que añada pequeñas variaciones al azar en el array de los individuos de la nueva generación.
"""

def mutation(population):
	"""
		Se mutan los individuos al azar. Sin la mutacion de nuevos genes nunca podria
		alcanzarse la solucion.
	"""
	
	for i in range(len(population)-pressure):

		if random.random() <= mutation_chance: #Cada individuo de la poblacion (menos los padres) tienen una probabilidad de mutar
			r=True
			while r:
				copiPopulation=population #copia de la poblacion para evaluar limites
				punto = random.randint(0,largo-1) #Se elgie un punto al azar
				nuevo_valor = random.randint(0,1) #y un nuevo valor para este punto

				#Es importante mirar que el nuevo valor no sea igual al viejo
				while nuevo_valor == population[i][punto]:
					nuevo_valor = random.randint(0,1)
				copiPopulation[i][punto] = nuevo_valor
				nuevo_num_vec=copiPopulation[i]
				num=convertirVectoraBinario(nuevo_num_vec)
				if num>=minPob and num<=maxPob:
					r=False
					population[i][punto] = nuevo_valor
				#Se aplica la mutacion
				
				
	
	return population

def reDefinirNuevoModelo(population):
		for i in population:
			definirModelo(i)
def graficar(x,y):
	
	grafico=plt.figure("Grafico")
	plt.ioff()
	plt.title("Individuos Modelos en Funcion")
	plt.xlabel("generations")
	plt.ylabel("Individuos")
	plt.xticks(np.arange(0,generations+1,10))
	plt.yticks(np.arange(0,maxPob+1,10))
	plt.grid(True)
	plt.axhline(maxPob, color='r', label='Maxima Poblacion')
	plt.axhline(minPob, color='r', label='Minima Poblacion')
	plt.plot(listamodelos)
	print(str(np.arange(0,maxPob+1,10)))
	print(str(y))
	grafico.show()
	
"""GUI"""

class Aplicacion():
	def __init__(self):
		self.raiz = Tk() # Define la ventana principal de la aplicación
		self.raiz.geometry('1400x800')
		self.raiz.resizable(0,0) # Establece que no se pueda cambiar el tamaño de la ventana
		self.raiz.configure(bg = 'beige') # Asigna un color de fondo a la ventana.
		self.raiz.title('Algoritmo Genetico') # Asigna un título a la ventana
		self.raiz.iconbitmap(default='genetica-icono-de-adn.ico')
		fuente= font.Font(weight='bold')
		#ETIQUETAS
		self.etiqMinPob = ttk.Label(self.raiz, text="Rango Min de Poblacion:", font=fuente)
		self.etiqMaxPob = ttk.Label(self.raiz, text="Rango Max de Poblacion:", font=fuente)
		self.etiqLong = ttk.Label(self.raiz, text="Longitud del Material", font=fuente)
		self.etiqCant = ttk.Label(self.raiz, text="Muestra de individuos:", font=fuente)
		self.etiqMuta = ttk.Label(self.raiz, text="(%) de Mutacion:", font=fuente)
		self.etiqGen = ttk.Label(self.raiz, text="Generaciones:", font=fuente)
		self.etiqModel = ttk.Label(self.raiz, text="Modelo Final:", font=fuente)

		#Variables de Entorno
		self.minPob=IntVar(value=1)
		self.maxPob=IntVar(value=100)
		self.largo=IntVar(value=10)
		self.num=IntVar(value=10)
		self.mutation_chance=DoubleVar(value=0.3)
		self.generations=IntVar(value=100)

		#CAJAS DE TEXTO
		self.ctextMinPob = ttk.Entry(self.raiz, textvariable=self.minPob, width=30)
		self.ctextMaxPob = ttk.Entry(self.raiz, textvariable=self.maxPob, width=30)
		self.ctextLong = ttk.Entry(self.raiz, textvariable=self.largo, width=30)
		self.ctextCant = ttk.Entry(self.raiz, textvariable=self.num, width=30)
		self.ctextMuta = ttk.Entry(self.raiz, textvariable=self.mutation_chance, width=30)
		self.ctextGen = ttk.Entry(self.raiz, textvariable=self.generations, width=30)
		self.separ1 = ttk.Separator(self.raiz, orient=HORIZONTAL)
		self.combo=ttk.Combobox(self.raiz, state="readonly")
		self.combo["values"]= ["Lineal(x)","Cuadratica(x^2)"]
		self.tinfo = Text(self.raiz, width=80, height=30) # Define el widget Text 'self.tinfo ' en el que se pueden introducir varias líneas de texto:
		self.separ2 = ttk.Separator(self.raiz, orient=HORIZONTAL)
		self.modeloFinal=Text(self.raiz,  width=15, height=4 )
		#Graficas
		#ylabel='\n Individuos'
		#xlabel='\n Generaciones'
		#self.figModel	=	Figure( figsize=(5,3), dpi=100)
		#self.axis = self.figModel.add_subplot(111)
		#self.axis.plot(x, y, color='#2b8ef9')
		#self.axis.fill_between(x, y, facecolor='#2b8ef9')
		#self.axis.grid(True)
		#self.axis.set_ylim(bottom=0)
		#self.axis.set_ylabel(ylabel)
		#self.axis.set_xlabel(xlabel)	
		#self.figModel.set_facecolor('white')
		
		#a = self.figModel.add_subplot(111).plot(x,)
		#self.figModel=plt()
		#plt.title("Individuos Modelos en Funcion")
		#plt.figure(figsize=(3,1))
		#plt.xlabel("generations")
		#plt.ylabel("Individuos")
		#plt.xticks(np.arange(0,generations,10))
		#plt.yticks(np.arange(0,maxPob,10))
		#dataPlot = FigureCanvasTkAgg(self.figModel, master=self.raiz)
		#dataPlot.draw()
		
		#BOTONES
		self.binfo = ttk.Button(self.raiz, text='Info', padding=(5,5), command=self.verinfo) #Define el widget Button 'self.binfo' que llamará al metodo 'self.verinfo' cuando sea presionado
		self.bsalir = ttk.Button(self.raiz, text='Salir', #Define el botón 'self.bsalir'. En este caso  cuando sea presionado, el método destruirá o terminara la aplicación-ventana 'self.raíz' con 'self.raiz.destroy'
								 padding=(5,5), command=self.raiz.destroy)
		

		#AJUSTANDO WIDGETS
		self.etiqMinPob.place(x=40, y=80)
		self.ctextMinPob.place(x=40, y=100)
		self.etiqMaxPob.place(x=250, y=80)
		self.ctextMaxPob.place(x=250, y=100)
		self.etiqLong.place(x=460, y=80)
		self.ctextLong.place(x=460, y=100)
		self.etiqCant.place(x=680, y=80)
		self.ctextCant.place(x=680, y=100)
		self.etiqMuta.place(x=900, y=80)
		self.ctextMuta.place(x=900, y=100)
		self.etiqGen.place(x=1100, y=80)
		self.ctextGen.place(x=1100, y=100)
		self.combo.place(x=40, y=120)
		self.separ1.place(x=5, y=140, bordermode=OUTSIDE, height=10, width=1320)
		self.tinfo.place(x=40, y=150) # Sitúa la caja de texto 'self.tinfo' en la parte INFERIOR
		self.etiqModel.place(x=700, y=150)
		self.modeloFinal.place(x=700, y=200)
		#dataPlot.get_tk_widget().place(x=500, y=150)
		self.separ2.place(x=5, y=650, bordermode=OUTSIDE, height=10, width=1320)
		self.binfo.place(x=40, y=700) #Coloca el botón 'self.binfo' debajo y a la izquierda del widget anterior
		self.bsalir.place(x=1300, y=700) #Coloca el botón 'self.bsalir' a la derecha del  objeto anterior.

		self.binfo.focus_set() #El foco de la aplicación se sitúa en el botón  'binfo' resaltando su borde.
		self.raiz.mainloop()

	def verinfo(self):

		error_dato=False
		global minPob
		global maxPob
		#global largo
		global num
		global mutation_chance
		global generations
		global pressure
		global funcion
		try:
			minPob=int(self.minPob.get())
			maxPob=int(self.maxPob.get())
			#largo=int(self.largo.get())
			num=int(self.num.get())
			mutation_chance=float(self.mutation_chance.get())
			generations=int(self.generations.get())
			pressure = int(round(num*0.3))
			funcion= str(self.combo.get())
		except:
			error_dato=True
		self.tinfo.delete("1.0", END) # Borra el contenido que tenga en un momento dado la caja de texto
		self.modeloFinal.delete("1.0", END)
		if not error_dato:
			population = crearPoblacion()#Inicializar una poblacion
			texto_info= "\n Poblacion Inicial:\n"+ str(population)+"\n"
			#SE EVOLUCIONA LA POBLACION
			for i in range(generations):
				population = selection_and_reproduction(population)
				population = mutation(population)
				reDefinirNuevoModelo(population)
				listamodelos.append(convertirVectoraBinario(modelo))
			texto_info+= "\nModelo:\n"+ str(modelo)+"\n"
			texto_info+= "\nPoblacion Final:\n"+ str(population)+"\n"
			texto_modelo=str(convertirVectoraBinario(modelo))
			#self.axis.plot(x,listamodelos,color='#2b8ef9')
			#dataPlot = FigureCanvasTkAgg(self.figModel, master=self.raiz)
			#dataPlot.draw()
			x=np.arange(0,generations,1)
			graficar(x, listamodelos)
			listamodelos.clear()
		else:
			texto_info="¡ERROR! REVISA DATOS"
		self.tinfo.insert("1.0", texto_info)
		self.modeloFinal.insert("1.0", texto_modelo)

		
def main():
	mi_app = Aplicacion()
	return 0

if __name__ == '__main__':
	main()
